---
title: IOR中文文档
description: 
published: true
date: 2022-07-09T08:11:34.918Z
tags: ior, 性能测试
editor: markdown
dateCreated: 2022-06-23T09:21:59.383Z
---

# IOR

IOR是一个并行的IO基准，可用于测试使用各种接口和访问模式的并行存储系统的性能。接口和访问模式的并行存储系统的性能。IOR资源库还包括mdtest基准，专门测试不同目录结构下存储系统的元数据峰值速率。在不同目录结构下存储系统的元数据峰值速率。这两个基准都使用一个共同的并行 I/O抽象后端，并依靠MPI进行同步。本文档由两部分组成。用户文档包括安装说明（Install），初学者教程（IOR的第一步），以及关于IOR的运行时选项的信息。开发者文档包括用Doxygen生成的代码文档和一些关于与Travis的连续整合的说明。IOR/mdtest用户和开发者文档的许多方面都是不完整的，我们鼓励贡献者 鼓励贡献者直接评论代码或在此基础上扩展文档。

## 源文档链接

[https://buildmedia.readthedocs.org/media/pdf/ior/latest/ior.pdf](https://buildmedia.readthedocs.org/media/pdf/ior/latest/ior.pdf)

## 2.安装

0.  如果顶层目录中缺少 "configure"，你可能直接从版本库中检索了这段代码。运行"./bootstrap"。如果你的自动工具的版本还不够新，无法运行这个脚本，请下载官方的压缩包，其中已经提供了configure脚本已经被提供了。  
    
1.  运行"./configure"。关于配置选项，见"./configure -help"。  
    
2.  运行 "make"。  
    
3.  可选地，运行 "make install"。安装前缀可以作为 "configure "脚本的一个选项来改变  
    

## 3\. IOR第一步

这是一个简短的教程，介绍IOR的基本用法，以及如何使用IOR来处理缓存效应的一些提示，因为这些效应很可能会影响你的测量。

### 3.1 运行IOR

有两种运行IOR的方法。1）带参数的命令行--可执行文件后有命令行选项。:: $ ./IOR -w -r -o filename这将对文件 "filename "进行写和读。

2.  带脚本的命令行 - 命令行中的任何参数都将建立测试运行的默认值。但在执行代码的过程中，可以结合使用脚本来进行不同的特定测试。只有脚本前的参数才会被使用!$ ./IOR -W -f script这默认了'script'中的所有测试都使用写数据检查。  
    

在本教程中，使用第一个选项，因为它更容易玩弄和了解IOR。第二个选项对安全基准设置更有用，以便以后重新运行或测试许多不同的情况。

### 3.2 IOR的入门

IOR按顺序写入数据，参数如下。

-   块大小 (-b)  
    
-   转移大小 (-t)  
    
-   段计数 (-s)  
    
-   任务数(-n)  
    

其中最好用图表来说明：

![image-20220102230857257[1].png](https://ucc.alicdn.com/pic/developer-ecology/f27986c8a5004c3fa7543a15a61aed3a.png "image-20220102230857257[1].png")

这四个参数是你开始使用IOR的全部需要。然而，天真地运行IOR通常会得到令人失望的结果。例如，如果我们运行一个四节点的IOR测试，总共写了16GiB

$ mpirun \-n 64 ./ior \-t 1m \-b 16m \-s 16

...

access bw(MiB/s) block(KiB) xfer(KiB) open(s) wr/rd(s) close(s) total(s) iter

\------ \--------- \---------- \--------- \-------- \-------- \-------- \-------- \----

write  427.36    16384      1024.00   0.107961 38.34    32.48    38.34    2

read   239.08    16384      1024.00   0.005789 68.53    65.53    68.53    2

remove \-         \-          \-         \-        \-        \-        0.534400 2

我们只能从Lustre文件系统中获得每秒几百兆的数据，而该系统应该能够获得更多的数据。更多。使用-F(filePerProcess=1)选项，从向单个共享文件写入到每个进程写入一个文件，会改变性能有了很大的改变。

$ mpirun \-n 64 ./ior \-t 1m \-b 16m \-s 16 \-F

...

access bw(MiB/s) block(KiB) xfer(KiB) open(s) wr/rd(s) close(s) total(s) iter

\------ \--------- \---------- \--------- \-------- \-------- \-------- \-------- \----

write  33645     16384      1024.00   0.007693 0.486249 0.195494 0.486972 1

read   149473    16384      1024.00   0.004936 0.108627 0.016479 0.109612 1

remove \-         \-          \-         \-        \-        \-        6.08     1

这在很大程度上是因为让每个MPI进程在自己的文件上工作，可以避免因文件锁定而产生的任何争执。因为文件锁定而产生的争论。然而，我们的天真测试和按文件进程测试之间的性能差异有点极端。事实上，唯一能在Lustre上实现146GB/秒读取率的方法是，四个计算节点中的每一个都有超过45GB/秒的网络带宽到Lustre--也就是说，每个计算和存储节点上都有400Gbit的链接。

### 3.3 页面缓存对基准测试的影响

真正发生的情况是，IOR读取的数据实际上并不是来自Lustre；相反，文件的内容已经被缓存了。已经被缓存了，而IOR能够直接从每个计算节点的DRAM中读取它们。这些数据在IOR的写阶段被由于Linux（和Lustre）使用回写缓存来缓冲I/O，所以数据在IOR的写入阶段被缓存了。因此，与其说IOR直接向Lustre读写数据，不如说它实际上主要是在与每个计算节点上的内存对话节点上的内存。更具体地说，尽管每个IOR进程认为它是在向Lustre上的一个文件写入，然后从Lustre上读回文件的内容，但实际上它是在

1.  向缓存在内存中的文件副本写入数据。如果在写之前内存中没有缓存的文件副本前，被修改的部分会先被加载到内存中。  
    
2.  文件在内存中的那些部分（称为 "页"），现在与Lustre上的内容不同，被标记为是 "脏 "的  
    
3.  Write()调用完成，IOR继续进行，尽管写入的数据还没有被提交到Lustre  
    
4.  独立于IOR，操作系统内核持续扫描文件缓存，以寻找在内存中被更新的文件，但不是在Lustre上的文件。但不在Lustre上的文件("脏页")，然后将缓存中的修改提交给Lustre  
    
5.  脏页被宣布为非脏页，因为它们现在与磁盘上的内容同步，但它们仍然在内存中。  
    

然后，当IOR的读取阶段紧接着写入阶段时，IOR就能够从内存中检索文件的内容了而不是通过网络与Lustre进行通信。

有几种方法可以衡量底层Lustre文件系统的读取性能。最粗略的方法是是简单地写入比总页缓存所能容纳的更多的数据，以便在写入阶段完成时。文件的开头部分已经被从缓存中驱逐了。例如，增加段数（-s）以写入更多的数据，可以很清楚地看到我的测试系统上的节点的页面缓存在哪一点上耗尽。

![image-20220102232157003[1].png](https://ucc.alicdn.com/pic/developer-ecology/718278c078014c01a2a224c4e0aee5fd.png "image-20220102232157003[1].png")

然而，这可能会使在有大量节点内存的系统上运行IOR花费很长时间。一个更好的选择是让每个节点上的MPI进程只读取它们没有写入的数据。比如说。在一个每节点四个进程的测试中，将MPI进程与块的映射转移四次，使每个节点N读取节点N-1写入的N-1节点写入的数据。

![image-20220102232243437[1].png](https://ucc.alicdn.com/pic/developer-ecology/dee34674bcc44241acfb3fe768c7f41a.png "image-20220102232243437[1].png")

由于页面缓存不在计算节点之间共享，以这种方式转移任务可以确保每个MPI进程都在读取它没有写入的数据。读取它没有写入的数据。IOR提供了-C选项（reorderTasks）来做到这一点，它迫使每个MPI进程读取其邻近节点所写的数据。邻近节点写入的数据。用这个选项运行IOR可以得到更可靠的读取性能。

$ mpirun \-n 64 ./ior \-t 1m \-b 16m \-s 16 \-F \-C

access bw(MiB/s) block(KiB) xfer(KiB) open(s) wr/rd(s) close(s) total(s) iter

\------ \--------- \---------- \--------- \-------- \-------- \-------- \-------- \----

write  41326     16384      1024.00   0.005756 0.395859 0.095360 0.396453 0

read   3310.00   16384      1024.00   0.011786 4.95     4.20     4.95     1

remove \-         \-          \-         \-        \-        \-        0.237291 1

但现在看来，写性能也高得离谱，这应该是很明显的。而且，这也是由于页面缓存的原因，它向IOR发出信号，当写被提交到内存中时就完成了，而不是由于 底层的Lustre文件系统。为了解决页面缓存对写性能的影响，我们可以在所有的 后立即发出fsync()调用，强制将我们刚刚写的脏页冲出到Lustre。包括fsync()所花费的时间 完成的时间给了我们一个衡量我们的数据写到页面缓存以及页面缓存写到 写回Lustre。IOR提供了另一个方便的选项，-e (fsync)，就是为了做这个。而且，再一次，使用这个选项改变了我们的性能测量有了很大的改变。

$ mpirun \-n 64 ./ior \-t 1m \-b 16m \-s 16 \-F \-C \-e

...

access bw(MiB/s) block(KiB) xfer(KiB) open(s) wr/rd(s) close(s) total(s) iter

\------ \--------- \---------- \--------- \-------- \-------- \-------- \-------- \----

write  2937.89   16384      1024.00   0.011841 5.56     4.93     5.58     0

read   2712.55   16384      1024.00   0.005214 6.04     5.08     6.04     3

remove \-         \-          \-         \-        \-        \-        0.037706 0

我们终于有了一个可信的文件系统的带宽测量。

### 3.4 击败页面缓存

由于IOR是专门为测试I/O而设计的，它提供了这些选项，使其尽可能容易地确保 你实际上是在测量你的文件系统的性能，而不是你的计算节点的内存。也就是说，它所产生的I/O模式是用来展示峰值性能的，而不是反映一个真正的应用程序可能要做的事情，因此，在很多情况下，用IOR测量I/O性能并不总是最佳选择。有几种方法可以让我们变得更聪明，在更普遍的意义上打败页面缓存，从而得到有意义的性能数字。当测量写性能时，绕过页面缓存其实很简单；打开一个带有O\_DIRECT 标志的文件直接进入磁盘。此外，可以将fsync()调用插入到应用程序中，正如IOR的-e选项所做的那样。衡量读取性能要棘手得多。如果你有幸在一个测试系统上有root权限，你可以 强制Linux内核清空其页面缓存，方法是 :: # echo 1 > /proc/sys/vm/drop\_caches 事实上，在运行任何基准测试（例如Linpack）之前，这通常是很好的做法，因为它可以确保你不会因为内核试图清空页面缓存而损失性能。损失性能，因为当你的基准程序开始为自己分配内存时，内核会试图驱逐页面。自己使用的内存时，你不会因为内核试图驱逐页面而损失性能。不幸的是，我们中的许多人在我们的系统上没有root权限，所以我们必须变得更加聪明。事实证明，有一种方法可以将提示传递给你。有一种方法可以向内核传递一个提示，告诉它一个文件不再需要放在页面缓存中了。

#define \_XOPEN\_SOURCE 600

#include <unistd.h>

#include <fcntl.h>

int main(int argc, char \*argv\[\]) {

int fd;

fd \= open(argv\[1\], O\_RDONLY);

fdatasync(fd);

posix\_fadvise(fd, 0,0,POSIX\_FADV\_DONTNEED);

close(fd);

return 0;

}

使用posix\_fadvise()传递POSIX\_FADV\_DONTNEED的效果通常是所有属于该 文件的所有页面都会从Linux的页面缓存中被驱逐。然而，这只是一个提示--而不是保证--而且内核是异步地驱逐这些页是异步的，所以可能需要一到两秒钟的时间才能真正离开页面缓存。幸运的是，Linux还提供了一种方法来探测文件中的页面，看看它们是否驻留在内存中。最后，通常最简单的做法是限制用于页面缓存的内存量。因为应用程序的内存总是优先于缓存内存，简单地分配一个节点上的大部分内存将迫使大部分的缓存页面被驱逐。新版本的IOR提供了memoryPerNode选项，就是这样做的，其效果是人们所期望的。

![image-20220103104523714[1].png](https://ucc.alicdn.com/pic/developer-ecology/c4ac1c8dd81a423e8694d2af1f58a62b.png "image-20220103104523714[1].png")

上图显示了一个拥有128GiB总DRAM的单一节点的测量带宽。每个x标签上的第一个百分比是这128GiB中被基准保留为应用内存的数量，第二个百分比是总写入量。例如，"50%/150%"的数据点对应于50%的节点内存（64GiB）被分配给应用程序，以及总共192GiB的数据被读取。这个基准是在一个旋转的磁盘上运行的，这个磁盘的速度不超过130MB/秒，所以显示性能高于这个速度的条件是得益于一些页面从缓存中提供。考虑到在相对于读取的数据量而言，有大量的内存用于缓存时，获得了异常高的性能测量值，这就非常合理了。

### 3.5 推论

测量I/O性能比CPU性能要棘手一些，这在很大程度上是由于页面缓存的影响。 也就是说，页面缓存的存在是有原因的，而且在很多情况下，一个应用程序的I/O性能 在很多情况下，一个应用程序的I/O性能最好由一个大量使用缓存的基准来代表。例如，BLAST生物信息学应用程序对其所有的输入数据进行了两次重读；第一次初始化数据结构，第二次填充数据结构。结构，而第二次则将其填满。因为第一次读取会缓存每一页，并允许第二次读取 由于第一次读取会缓存每一页，并允许第二次读取来自缓存而不是文件系统，在禁用页面缓存的情况下运行这种I/O模式会导致其速度降低约 2倍的速度。

![image-20220103105228641[1].png](https://ucc.alicdn.com/pic/developer-ecology/9b86bdd5c43049f1a659732afab28626.png "image-20220103105228641[1].png")

因此，让页面缓存做它的事情往往是最现实的方式，以现实的应用I/O 模式。一旦你知道页面缓存是如何影响你的测量结果的，你就有可能推理出什么是最有意义的性能指标。

## 4\. 选项

IOR提供了许多选择，事实上，现在的选择比字母表中的一个字母旗帜还多。为此，为了通过配置脚本来运行IOR，有些选项只能通过指令来实现。当脚本和 命令行选项都在使用时，设置在-f前面的命令行选项是默认的，可以被脚本所覆盖。指令也可以通过"-O "选项从命令行设置。在与脚本的结合中，它们的行为与普通的命令行选项一样。但是指令和普通参数是相互覆盖的，所以最后一个执行。

### 4.1 命令行选项

这些选项要在命令行中使用（例如，./ior -a POSIX -b 4K）

-   S是一个字符串，N是一个整数。  
    
-   对于传输和块大小，不区分大小写的K、M和G就可以被识别。例如，'4k'或'4K'被认为是 接受为4096。  
    

各种选项只对特定的模块有效，你可以在运行$ ./ior -h时看到细节。通常以模块名称为前缀，例如：-posix.odirect

### 4.2 指令选项

对于以下所有真/假选项，\[1\]=true，\[0\]=false。所有选项都不区分大小写

#### 4.2.1 一般情况下

-   refNum - 用户提供的参考编号，包括在长摘要中（默认：0）。  
    
-   api - 必须设置为POSIX、MPIIO、HDF5、HDFS、S3、S3\_EMC、NCMPI、IME、MMAP或RAODS其中之一，具体取决于测试（默认：POSIX） 其中之一，具体取决于测试（默认：POSIX）  
    
-   testFile - 输出文件的名称\[testFile\]。通过 -o S@S@S 在多个文件名之间循环。如果在这种情况下只指定了一个文件名，IOR会将MPI等级附加到生成的每个文件的末尾（例如，testFile.00000059）（默认：testFile）  
    
-   hintsFileName - 提示文件的名称（默认：无）  
    
-   repetitions - 运行每个测试的次数（默认为：1）  
    
-   multiFile - 为每个迭代的单共享文件或按进程的文件模式创建多个文件（默认：0）  
    
-   reorderTasksConstant - 通过一个恒定的节点偏移来重新排序任务，以便从不同的节点写入/读取邻居的数据。不同节点的数据（默认值：0）  
    
-   taskPerNodeOffset - 用于读取测试。与-C和-Z选项一起使用。与reorderTasks一起使用，常数N。与reordertasksrandom一起使用，>= N (默认：1)  
    
-   reorderTasksRandom - 为读取测试将任务重新排序为随机顺序(默认: 0)  
    
-   reorderTasksRandomSeed - reordertasksrandom选项的随机种子。(默认：0)

-   当>0时，对所有迭代使用相同的种子  
    
-   当<0时，每次迭代使用不同的种子  
    

-   quitOnError - 在checkWrite或checkRead中遇到错误时，显示当前错误，然后 停止执行。否则，计算错误并继续（默认：0）  
    
-   numTasks - 应该参与测试的任务数。0表示所有的任务。(默认：0)  
    
-   interTestDelay - 在一系列测试中开始写或读阶段之前的延迟时间（秒），在检查-写或检查-读阶段之前不延迟。(默认：0)  
    
-   outlierThreshold - 如果任何任务与所有参与任务的平均值相差超过这个秒数，则发出警告。参与的任务的平均值超过这个数字，就会发出警告。警告包括违规的任务，它的计时器（开始、创建时间、传输时间、结束时间），以及所有任务的平均值和标准偏差。结束），以及所有任务的平均值和标准偏差。当为零时，禁用此功能。(默认。0)  
    
-   intraTestBarriers - 在打开、写/读和关闭阶段之间使用障碍（默认：0）  
    
-   uniqueDir - 为每个文件-进程创建并使用唯一的目录（默认值：0)  
    
-   writeFile - 写入文件，首先删除任何已有的文件。writeFile和readFile的默认设置是，如果没有-w、-r、-W或-R中的至少一个，那么-w和-r将被启用。如果 writeFile 或 readFile 被明确地启用，那么它的补充部分就不会被隐含地启用。  
    
-   readFile - 读取由 testFile 选项指定的现有文件。writeFile 和 readFile 的默认设置是，如果没有 -w, -r, -W, 或 -R 中的至少一个，那么 -w 和 -r 会被启用。如果 writeFile 或 readFile 被明确地启用，它的补充部分就不会被隐式地启用。  
    
-   filePerProc - 让每个MPI进程对一个唯一的文件执行I/O（默认：0）  
    
-   checkWrite - 回读数据并根据已知模式检查错误。可以独立于 写文件。数据检查不计时，不影响其他性能计时。所有检测到的错误会被 并作为程序的退出代码返回，除非设置了退出错误（quitOnError）。(默认：0)  
    
-   checkRead - 重新读取数据并检查读取之间的错误。可以独立于readFile使用。数据检查不计时，不影响其他性能计时。所有检测到的错误都会被统计出来，并作为程序退出代码返回，除非退出。作为程序的退出代码返回，除非设置了quitOnError。(默认: 0)  
    
-   keepFile - 在程序退出时不删除测试文件 (默认: 0)  
    
-   keepFileWithError - 如果在读检查或写检查阶段检测到错误，不要删除任何含有错误的文件。阶段。(默认值: 0)  
    
-   useExistingTestFile - 在写入阶段前不删除测试文件（默认为0）。  
    
-   segmentCount - 文件中的段数，一个段是由多个客户端访问的连续的数据块，每个客户端写/读他们自己的连续的数据（块）。段的确切语义取决于所使用的API；例如，HDF5会重复整个共享数据集的模式。(默认：1)  
    
-   blockSize - 单个客户端访问的连续数据块的大小（字节）。它由一个或多个传输组成（默认：1048576）。  
    
-   transferSize - 在一次I/O调用中传输的单个数据缓冲区的大小（字节）（默认值：262144）。  
    
-   verbose - 输出更多关于IOR正在做什么的信息。可以设置为0-5级；重复使用-v标志会增加粗话级别。(默认值: 0)  
    
-   setTimeStampSignature - 用于时间戳签名的值。用于以精确的数据模式重新运行测试，通过设置数据签名包含正的整数值作为时间戳写入数据文件；如果设置为0，则被禁用（默认：0）  
    
-   showHelp - 显示选项和帮助（默认：0）  
    
-   storeFileOffset - 在写文件时使用文件偏移量作为存储签名。这将影响性能测量（默认：0）  
    
-   memoryPerNode - 在每个节点上分配内存，以模拟实际应用的内存使用情况或限制页面缓存大小。在支持以下功能的系统上，接受节点内存的一个百分比（例如50%）。sysconf(\_SC\_PHYS\_PAGES)或一个大小。分配将在共享节点的任务之间进行分配。(默认：0)  
    
-   memoryPerTask - 为每个任务分配指定数量的内存（以字节为单位），以模拟真实的应用程序内存使用。(默认：0)  
    
-   maxTimeDuration - 运行所有测试的最大时间（分钟）。任何当前的读/写阶段都不会被打断；一旦超过这个时间，只有未来的I/O阶段会被取消。值为0时，不设置禁用功能。(默认：0)  
    
-   deadlineForStonewalling - 停止写或读阶段前的秒数。用于测量在固定时间内移动的数据量。在屏障之后，每个任务启动自己的计时器，开始移动数据，并在预先安排的时间停止移动数据。这个选项不是测量移动固定数量的数据所需的时间，而是测量在固定时间内移动的数据量。其目的是为了防止滞后的任务缓慢地歪曲了性能。这个选项与读检查和写检查模式不兼容。写检查模式不兼容。值为0时，取消该选项。(默认值：0)  
    
-   randomOffset - 随机化测试文件中的访问偏移。目前与checkRead不兼容。storeFileOffset、MPIIO collective和useFileView，以及HDF5和NCMPI APIs不兼容。(默认：0)  
    
-   summaryAlways - 总是打印每个测试的长摘要，即使工作被中断。(默认：0)  
    

#### 4.2.2 POSIX-ONLY

-   useO\_DIRECT - 使用POSIX的直接I/O，绕过I/O缓冲区（默认：0）。  
    
-   singleXferAttempt - 不要继续重试传输整个缓冲区，直到它被传输。当在POSIX中执行write()或read()时，不能保证整个请求的缓冲区大小被传输；这个标志保持重试单一的传输，直到它完成或返回一个错误（默认：0）  
    
-   fsyncPerWrite - 在每次POSIX写入后执行fsync(默认为0)  
    
-   fsync - 在关闭POSIX文件后执行fsync (默认为：0)  
    

#### 4.2.3 MPIIO-ONLY

-   preallocate - 在写入前预分配整个文件（默认：0）。  
    
-   useFileView - 使用MPI数据类型来设置文件视图选项，使用单个文件指针。默认的IOR 使用显式文件指针。(默认：0)  
    
-   useSharedFilePointer - 使用一个共享文件指针。默认IOR使用显式文件指针。(缺省: 0)  
    
-   useStridedDatatype - 创建一个数据类型（最大=2GB）用于串联访问；类似于 MULTIBLOCK\_REGION\_SIZE (默认: 0)  
    

#### 4.2.4 HDF5-ONLY

-   individualDataSets - 在一个文件中，每个任务将访问它自己的数据集。默认IOR创建一个数据集，大小为numTasks \* blockSize，供所有任务访问（默认：0）。  
    
-   noFill - 在创建HDF5文件时不预先填充数据（默认：0）。  
    
-   setAlignment - 以字节为单位设置HDF5对齐方式（例如：8、4k、2m、1g）（默认：1)  
    
-   hdf5.collectiveMetadata - 启用 HDF5 集体元数据（自 HDF5-1.10.0 起可用）  
    

#### 4.2.5 MPIIO-, HDF5-, AND NCMPI-ONLY

-   collective - 使用集体操作进行访问（默认：0）。  
    
-   showHints - 显示附在打开的文件上的提示/值对。不适用于NCMPI。(缺省: 0)  
    

#### 4.2.6 LUSTRE-SPECIFIC

-   lustreStripeCount - 设置测试文件的Lustre条带计数（默认：0  
    
-   lustreStripeSize - 为测试文件设置Lustre条带大小(默认为：0)  
    
-   lustreStartOST - 设置测试文件的起始OST(默认为：-1)  
    
-   lustreIgnoreLocks - 禁用Lustre范围锁定(默认为0)  
    

#### 4.2.7 GPFS-SPECIFIC

-   gpfsHintAccess - 使用gpfs\_fcntl提示来预先声明访问（默认：0）。  
    
-   gpfsReleaseToken - 打开或创建文件后立即释放所有锁。当许多进程写/读同一个文件时，可能有助于减少锁的重新分配流量。(默认：0)  
    

### 4.3 Verbosity levels

IOR输出的粗略程度可以用-v来设置。增加命令行上的-v实例的数量可以设置 更高。下面是不同粗制滥造水平下的信息概览。

### 4.4 Incompressible notes

请注意，不可压缩性是指一个区块压缩算法使用多大的因素。不可压缩性的 缓冲区在写入前只被填充一次，所以如果压缩算法使用的块大于传输的 大小，就会有压缩。下面是zip、gzip和bzip的一些基线。

1.  zip。对于压缩文件，传输大小为1k就足够了。  
    
2.  gzip。对于gzipped文件，1k的传输大小就足够了。  
    
3.  bzip2：对于bzip文件，1k的传输大小是不够的（~50%的压缩）。为了避免压缩，传输 大于 bzip 块的大小是必需的（默认 = 900KB）。我建议传输的大小要大于 1MB来避免bzip2压缩。注意你的压缩算法将查看的块大小，并相应调整传输大小  
    

注意你的压缩算法将查看的块大小，并相应调整传输大小

## 5\. Scripting

IOR可以使用命令行中的-f选项来使用输入脚本。在给出'-f'选项之前，命令行上的任何选项 选项之前在命令行上设置的任何选项都将被视为运行脚本的默认设置。比如说

mpirun ./ior -W -f script

将以隐含的-W运行脚本中的所有测试。脚本本身可以覆盖这些设置，可以设置为在一次执行中运行许多不同的IOR测试。脚本本身可以覆盖这些设置，并且可以设置为在一次执行中运行许多不同的IOR测试，需要注意的是，任何在''-f''后面指定的命令行选项 在''-f''之后指定的任何命令行选项都不会被应用到脚本所规定的运行中。比如说

mpirun ./ior -f script -W

不会运行任何隐含的-W的测试，因为该参数在-f选项（及其组成运行）完成后才会应用。输入脚本是使用与每个命令行选项相对应的长格式选项名称来指定的。除了长格式选项之外。

-   IOR START和IOR END标志着脚本的开始和结束。  
    
-   RUN使用之前指定的所有选项来进行测试。  
    
-   所有先前设置的参数在下一次测试中保持设置。它们不会被重置为默认值。对于默认值，必须手动设置。  
    
-   脚本中的白色空间被忽略，以#开头的注释也被忽略。  
    
-   不是所有的测试参数都需要设置。  
    

示例脚本：

```
IOR START
    api=[POSIX|MPIIO|HDF5|HDFS|S3|S3_EMC|NCMPI|RADOS]
    testFile=testFile
    hintsFileName=hintsFile
    repetitions=8
    multiFile=0
    interTestDelay=5
    readFile=1
    writeFile=1
    filePerProc=0
    checkWrite=0
    checkRead=0
    keepFile=1
    quitOnError=0
    segmentCount=1
    blockSize=32k
    outlierThreshold=0
    setAlignment=1
    transferSize=32
    singleXferAttempt=0
    individualDataSets=0
    verbose=0
    numTasks=32
    collective=1
    preallocate=0
    useFileView=0
    keepFileWithError=0
    setTimeStampSignature=0
    useSharedFilePointer=0
    useStridedDatatype=0
    uniqueDir=0
    fsync=0
    storeFileOffset=0
    maxTimeDuration=60
    deadlineForStonewalling=0
    useExistingTestFile=0
    useO_DIRECT=0
    showHints=0
    showHelp=0
RUN
    
    transferSize=64
    blockSize=64k
    segmentcount=2
RUN
    transferSize=4K
    blockSize=1M
    segmentcount=1024
RUN
IOR STOP
```

## 6\. 版本兼容性

IOR有很长的历史，目前只有IOR的第3版被支持。然而，有许多基于早期版本的 IOR 分叉。然而，有许多基于早期版本的IOR分叉，并且已知主要版本之间存在以下不兼容的情况。

1.  IOR版本1（c. 1996-2002）和IOR版本2（c. 2003至今）不兼容。一个版本的输入卡 不会在另一个版本上工作。由于版本1不包括在这个版本中，这不应该是值得关注的情况。所有 后续的兼容性问题都是针对IOR第二版的。  
    
2.  2.8版之前的IOR版本提供的数据大小和速率是2的幂。例如，1MB/秒指的是 1,048,576字节/秒。在IOR 2.8版及以后的版本中，MB现在被定义为1,000,000字节 和MiB是1,048,576字节。  
    
3.  在IOR 2.5.3到2.8.7版本中，IOR的运行不需要任何命令行选项。这假定了如果 写和读选项(-w -r)被省略，运行时将它们都设置为默认。后来，人们发现，在 后来发现在某些情况下（如数据检查），这会造成困难。在IOR 2.8.8及以后的版本中，如果没有一个-w -r\-W或-R选项被设置，那么-w和-r将被隐含地设置。  
    
4.  IOR第3版（2012年1月至今）对IOR的输出有一些改变，"testNum "选项被改名为 改名为 "refNum"。  
    

## 7\. 常见问题

-   我如何在一个现有文件上进行多次数据检查？

-   使用这个命令行。**IOR -k -E -W -i 5 -o file**\-k 保留访问后的文件，而不是删除它 -E 使用现有文件，而不是截断它 首先 -W 执行写检查 -i 检查的迭代次数 -o 文件名 在2.8.8之前的IOR版本中，你还需要-r标志，否则你会首先覆盖现有的 文件。(在早期版本中，省略-w和-r意味着同时使用。这个语义后来被 改为省略-w、-r、-W和-R意味着同时使用-w和-r）。如果你正在运行新的测试来创建一个文件，并希望对这个文件进行多次重复的数据检查，有一个未记录的选项用于此目的 有一个未被记录的选项用于此。它是 -O multiReRead=1，你需要有一个 IOR 版本的 编译的 IOR 版本有 USE\_UNDOC\_OPT=1（在 iordef.h 中）。命令行应该是这样的。**IOR -k -E -w -W -i 5 -o file -O multiReRead=1**对于第一次迭代，文件将被写入（不包括数据检查）。然后对于任何其他迭代 (在这个例子中是四次)，文件将被重新读取，无论使用什么数据检查选项。  
    

-   IOR如何评估性能？

-   IOR执行得到一个时间戳START，然后让所有参与的任务打开一个共享或独立的文件。传输数据，关闭文件，然后得到一个STOP时间。在文件上执行stat()或MPI\_File\_get\_size()，并将其和其他文件进行比较。对文件进行stat()或MPI\_File\_get\_size()，并与传输的总数据量进行比较。如果这个值不匹配，就会发出一个 警告，并使用从write()计算出的数据传输量，例如，返回代码。计算出的带宽是传输的数据量除以经过的停止-开始-结束时间。IOR还获得时间戳，以报告开放、传输和关闭时间。这些时间中的每一个都是基于 任何任务的最早开始时间和任何任务的最新停止时间。如果不在这些操作之间使用屏障 这些操作之间没有使用屏障（-g），打开、转移和关闭时间的总和可能不等于从第一次打开到最后一次关闭的时间。第一次打开到最后一次关闭的时间  
    

-   如何在Ior中访问多个文件系统？

-   在使用filePerProc选项时，可以让任务在多个文件名之间轮流进行。与其使用单一的文件名"-o file"，不如使用额外的名字"-o file1@file2@file3"。在这种情况下，每个进程的一个文件将有三个不同的文件名（可能是全路径名）来访问。'@'分隔符是任意的，可以在iordef.h中的FILENAME\_DELIMITER定义中设置。注意，这个多文件名的选项只对filePerProc -F选项有效。这对共享文件不起作用  
    

-   如何在多个文件系统之间平衡？

-   至于每个文件系统的文件平衡，不同的文件系统提供不同的性能。同一目标路径的额外实例通常可以实现良好的平衡。例如，FS1的性能比FS2好50%，设置'-o'标志，使FS1目录有额外的实例。在这种情况下，'-o FS1/file@FS1/file@FS1/file@FS2/file@FS2/file' 应调整性能差异并相应地平衡  
    

-   如何使用STONEWALLING？（STONEWALLING在这种应该是一种阻塞、拖延的概念）

-   要使用STONEWALLING（-D），一般来说，最好把写测试和读测试分开。开始时，在写一个文件，以确定该文件需要多长时间被写入。如果它需要10 如果数据传输需要10秒，用更短的时间再次运行，例如'-D 7'，在文件完成前停止。完成之前停止，而不拖延时间。对于阅读来说，最好是创建一个完整的文件（而不是一个由拖延运行产生的未完全写入的 文件），然后在这个预先存在的文件上设置 "拖延 "来运行。如果写和读 如果在同一次运行中进行写和读的测试，很可能在读的时候会遇到错误，因为碰到了EOF。遇到EOF。分开运行可以纠正这个问题。例如。**IOR -w -k -o file -D 10** # 写入并保留文件，10秒后STONEWALLING **IOR -r -E -o file -D 7** # 读取 现有文件，7秒后石墙。另外，当运行多次只读STONEWALLING测试的迭代时，可能需要将-D 值足够高，以便每次迭代都不从缓存中读取。否则，在某些情况下，第一次 迭代可能会显示100MB/s，下一次是200MB/s，第三次是300MB/s。这些测试中的每一个实际上是 在规定的时间内从磁盘上读取相同的数量，但他们也在读取前一个测试的缓存数据，以获得 每次都在读取前一个测试的缓存数据，以获得增加的性能。将-D设置得足够高，以便缓存被过度填充。过度填充将防止这种情况  
    

-   当回读刚写的文件时，如何绕过缓存？

-   测试文件系统的一个问题是处理缓存的数据。当一个文件被写入时，该数据可能被储存在 在写文件的节点上。当同一个节点试图从文件系统中读回数据时 时，它可能会从自己的缓存中读取，而不是从文件系统中读取。从文件系统中读取。reorderTasksConstant '-C' 选项试图通过让不同的节点读回数据来解决这个问题 而不是写它。例如，节点N将数据写入文件，节点N+1读回数据用于读取性能，节点N+2读回数据用于写入数据检查，节点N+3读回数据用于读取数据 检查，将其与来自节点N+4的重读数据进行比较。其目的是确保在文件访问时 数据不是从缓存数据中读取的。 节点0：写数据 节点1：读数据 节点2：读书面数据进行写检查 节点3：读书面数据进行读检查 节点 4： 读书面数据进行读检查，与节点3比较 从N跳到N+1的算法，例如，期望在节点上有连续的任务编号（块分配），而不是那些轮流分配的任务（循环分配）。例如，一个在3个节点上运行6个任务的测试，期望任务0、1在节点0上；任务2、3在节点1上；任务4、5在节点2上。如果任务对节点的分配是轮流进行的，那么节点0上会有任务0,3；节点1上有任务1,4；而节点2上有任务2,5。在这种情况下，不存在任务不从节点上缓存的数据中读取的期望。  
    

-   如何使用提示？

-   可以按照这种形式向I/O库或文件系统层传递提示。

'setenv IOR\_HINT\_\_<layer>\_\_<hint> <value>'

-   例如：: 'setenv IOR\_HINT**MPI**IBM\_largeblock\_io true' 'setenv IOR\_HINT**GPFS**important\_hint true'  
    或者，在一个文件中的形式：：'IOR\_HINT**<layer>**<hint>\=<value>'  
    注意，从HDF5或NCMPI层给MPI的提示的形式是：：'setenv IOR\_HINT\_MPI\_<hint> <value>'

-   如何明确地设置文件数据签名？

-   传输的数据签名包含MPI任务号、传输缓冲区偏移量，以及迭代开始的时间戳 迭代开始的时间戳。由于IOR是用8字节长的长条形数据工作的，所以写入的偶数长条形数据 包含一个32位的MPI任务号和一个32位的时间戳。奇数的长条包含一个64位的 传输缓冲区的偏移量（如果使用'-l'storeFileOffset选项，则是文件偏移量）。要设置时间戳的值。使用'-G'或setTimeStampSignature  
    

-   如何轻松地检查或改变输出数据文件中的一个字节？

-   有一个简单的工具 IOR/src/C/cbif/cbif.c 可以建立。这是一个独立的串行应用程序，叫做cbif（Change Byte In File）。该工具允许检查一个文件偏移量，以IOR的数据检查格式返回该位置的数据。它还允许改变该位置的一个字节  
    

-   如何纠正集群中各节点间的时钟偏移？

-   为了纠正节点之间的时钟偏移，IOR比较节点之间的时间，然后广播根节点的时间戳，以便所有节点可以通过差异进行调整。节点的时间戳，这样所有的节点都可以根据差异进行调整。要看到一个恶劣的离群值，可以使用'-j'选项。一定要把这个值设置得足够高，只显示与平均值相差一定时间的节点。  
    

## 8\. Doxygen

点击[这里](https://buildmedia.readthedocs.org/media/pdf/ior/doxygen_html/index.html)获取doxygen。

本文档使用doxygen来解析c代码。因此，无论如何都会在后台创建一个doxygen实例。这可能是有帮助的，因为doxygen产生漂亮的调用图

## 9\. CI

持续集成用于基本的理智性检查。Travis-CI为开源的github项目提供免费的CI 并通过.travis.yml进行配置。

目前，这被设置为在ubuntu 14.04机器上编译IOR，后端为gcc 4.8、openmpi和hdf5。 这是一个非常基本的检查，随着时间的推移应该会有进步。然而，这应该能及早发现重大错误，因为 它们会在拉动请求中显示出来。

## 10\. 版本进度

### 10.1 一般发布过程

IOR的版本控制是在版本库根部的META文件中编码的。命名方法是

-   3.2.0指定一个适当的版本  
    
-   3.2.0rc1表示为3.2.0版本做准备的第一个候选版本  
    
-   3.2.0+dev表示在功能冻结之前向3.2.0开发。  
    
-   3.2.0rc1+dev表示在功能冻结后为3.2.0的第一个候选版本进行开发  
    

### 10.2 编译一个特定版本IOR

要建立一个新的IOR版本，例如，从3.2发布分支。

```
$ docker run -it ubuntu bash
$ apt-get update
$ apt-get install -y git automake autoconf make gcc mpich
$ git clone -b 3.2 https://github.com/hpc/ior
$ cd ior
$ ./travis-build.sh
```

另外，你也可以在Docker中使用bind mount来构建一个任意的分支。这将在未来被包装成一个buildrelease的Docker文件。

```
$ docker run -it --mount type=bind,source=$PWD,target=/ior ubuntu
$ apt-get update
$ apt-get install -y git automake autoconf make gcc mpich
$ ./travis-build.sh
```